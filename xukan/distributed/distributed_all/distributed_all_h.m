function N=distributed_all_h(A,j,L,H,num)
% A:节点自身维护的消息矩阵
% j:当前同步轮数
% num:无人机总数
% L:自身节点频率补偿值
% H:自身节点相位补偿值
% N:返回值，(1,1)表示h补偿值，后面的num行，表示本次接收到的真实邻居消息所对应的h补偿值

%初始化返回值矩阵
N=zeros(num+1,2);

%逻辑时钟相位调整
deltah=zeros(num+num*num,1);%每个节点对应的相位调整值

m=1;
B=zeros(2,5);%第一行表示邻居的逻辑时钟，第二行表示自身的逻辑时钟

%遍历矩阵A
for n=1:num
    if A(n,1)>=j-1
        for k1=1:5
            A(n,2*k1+1)=A(n,2*k1+1)-A(n,14);%传播时延补偿
        end
        for k1=1:5
            B(1,k1)=A(n,2*k1)*A(n,12)+A(n,13);
            B(2,k1)=A(n,2*k1+1)*L+H;
        end
        deltah(n,1)=(B(1,1)-B(2,1)+B(1,2)-B(2,2)+B(1,3)-B(2,3)+B(1,4)-B(2,4)+B(1,5)-B(2,5))/5;
        m=m+1;
        N(n+1,1)=A(n,1);
        N(n+1,2)=(B(1,1)-B(2,1)+B(1,2)-B(2,2)+B(1,3)-B(2,3)+B(1,4)-B(2,4)+B(1,5)-B(2,5))/5;
        
        %遍历该有效邻居信息的二跳矩阵（后n列），计算结果加入deltah中，递增计数器m
       for k5=15:14+num
           if (A(n,k5)~=0)&&(~(A(k5-15+1,1)>=j-1))
               deltah(num+num*(n-1)+k5-14,1)=A(n,k5)+(B(1,1)-B(2,1)+B(1,2)-B(2,2)+B(1,3)-B(2,3)+B(1,4)-B(2,4)+B(1,5)-B(2,5))/5;
               m=m+1;
           end
       end
    end
end
N(1,1)=H+(sum(deltah))/m;
N(1,2)=m;
end